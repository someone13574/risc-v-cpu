## Design Files

This directory contains the design files for the CPU. Here is a brief description of the resposibilities of each file.

- `cpu.sv`: The top level module. This file connects all of the other systems together and generates the clock enable signal.
- `control_unit.sv`: This module is responsible for the evaluation of branch conditions, incrementation of the program counter, adversion of data dependencies & resource conflicts, and executing jumps.
- `data_dep_detector.sv`: This file detects data dependencies in registers before they become effectful. This module is instantiated by the control unit. See [data-dependency.md](../docs/data-dependency.md) for more details.
- `instruction_decoder.sv`: This module creates a lookup address used to index the `rom` module, which contains the microcode for each instruction.
- `instruction_data.sv`: This module contains a package with functions for extracting immediates and register addresses from instructions.
- `microcode.sv`: This module contains a package with functions for accessing named microcode bits.
- `lpm_ram_dq.sv`: This is a stub file used to allow linting to pass outside of Quartus II. It should not be included in a Quartus II project.
- `memory.sv`: This module instaniates embedded memory blocks, the memory management unit, and the memory mapped IO module.
- `mmu_encode.sv`: This module maps virtual addresses into the physical addresses and write enable signals used by the embedded memory blocks (which there are eight of). This is needed to properly handle non-word-aligned reads and writes, as well as truncated/sign-extended reads and writes.
- `mmu_decode.sv`: This module does the reverse of `mmu_encode`; It maps the output data of the embedded memory blocks into the actual word which was read, as well as truncating and sign-extending as necessary.
- `mmio.sv`: This module handles reading and writing from memory mapped IO, which isn't stored in the embedded memory blocks so that output can be continuous.
- `registers.sv`: This module contains & handles the 16 registers used by RV32E.
- `pre_writeback.sv`: Since writeback to the registers can have three sources (the upper immediate, the alu output, or the return address), this module multiplexes this signal a cycle early so relax timing requirements.
- `alu.sv`: This module executes arthimatic and logic operations.
- `pre_alu.sv`: This module acts in the same vain as `pre_writeback.sv`. It multiplexes the ALU input signals a cycle before they are needed.
- `upload_rx.sv`: This module handles the raw uart inputs and generates the addresses needed to write to memory.
- `uart_rx.sv`: This module receives uart signals and outputs bytes as they are read.
- `uart_tx.sv`: This module transmits bytes over the uart connection. It is connected to mmio.
- `microcode.mem`: This isn't a module, but it contains the microcode lookup for each instruction. There are gaps inbetween different instructions to reduce the logic needed in `instruction_decoder.sv` to generate addresses. This file is generated by the `generate-microcode` command of the CLI, and can be written to this location by using the `--write` option (or `-w`). If the write option isn't used, it is only printed to STDOUT.
